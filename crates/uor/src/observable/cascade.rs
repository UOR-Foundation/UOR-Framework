//! Cascade spectrum observable for computation paths.
//!
//! The cascade spectrum decomposes each transition into its carry-cascade signature.
//! For successor operations, the cascade length equals the number of bits that flip.

use super::PathObservable;
use alloc::vec;
use alloc::vec::Vec;

/// Cascade spectrum observable.
///
/// The cascade spectrum is a histogram of cascade lengths observed along a path.
/// For a path generated by successor operations:
///
/// ```text
/// CS[k] = #{i : cascade_length(xᵢ, xᵢ₊₁) = k}
/// ```
///
/// For random starting points, the theoretical distribution is P(k) = (1/2)^k
/// for k < quantum, with a boundary correction at k = quantum.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct CascadeSpectrum {
    /// Histogram bins: bins[k] = count of transitions with cascade length k.
    /// Index 0 is unused (cascade length is always >= 1).
    pub bins: Vec<u32>,
}

impl PathObservable for CascadeSpectrum {
    type Value = Vec<u32>;

    fn compute(path: &[u64], quantum: u32) -> Self::Value {
        cascade_spectrum(path, quantum)
    }
}

/// Compute cascade length for a successor transition.
///
/// Cascade length is the Hamming distance between a value and its successor.
/// This equals the number of trailing 1-bits plus 1 (the bit that sets).
///
/// # Arguments
///
/// * `value` - The value before the successor operation
/// * `quantum` - Bit width of the ring
///
/// # Returns
///
/// The cascade length (1 to quantum inclusive).
///
/// # Example
///
/// ```
/// use uor::observable::cascade_length;
///
/// assert_eq!(cascade_length(0, 8), 1);   // 0 → 1: one bit flips
/// assert_eq!(cascade_length(1, 8), 2);   // 1 → 2: two bits flip
/// assert_eq!(cascade_length(3, 8), 3);   // 3 → 4: three bits flip
/// assert_eq!(cascade_length(7, 8), 4);   // 7 → 8: four bits flip
/// assert_eq!(cascade_length(255, 8), 8); // 255 → 0: all bits flip
/// ```
pub fn cascade_length(value: u64, quantum: u32) -> u32 {
    if quantum == 0 || quantum > 64 {
        return 0;
    }

    let mask = if quantum >= 64 {
        u64::MAX
    } else {
        (1u64 << quantum) - 1
    };

    let masked = value & mask;

    // All ones case: all bits flip (wrap around)
    if masked == mask {
        return quantum;
    }

    // Count trailing 1-bits, then add 1 for the bit that sets
    let trailing_ones = (!masked).trailing_zeros();
    trailing_ones.min(quantum) + 1
}

/// Compute the cascade spectrum of a path.
///
/// Returns a histogram where bins[k] is the count of transitions
/// with cascade length k.
///
/// # Arguments
///
/// * `path` - Sequence of values representing the computation path
/// * `quantum` - Bit width of the ring
///
/// # Returns
///
/// A vector of length (quantum + 1) where index k holds the count of
/// transitions with cascade length k. Index 0 is always 0.
///
/// # Example
///
/// ```
/// use uor::observable::cascade_spectrum;
///
/// // Successor path 0 → 1 → 2 → 3
/// // Cascade lengths: 1, 2, 1
/// let path = [0u64, 1, 2, 3];
/// let spectrum = cascade_spectrum(&path, 8);
///
/// assert_eq!(spectrum[1], 2); // Two transitions with cascade length 1
/// assert_eq!(spectrum[2], 1); // One transition with cascade length 2
/// ```
pub fn cascade_spectrum(path: &[u64], quantum: u32) -> Vec<u32> {
    let mut spectrum = vec![0u32; quantum as usize + 1];

    if path.len() < 2 || quantum == 0 {
        return spectrum;
    }

    for window in path.windows(2) {
        // Assume successor-like transitions
        let cl = cascade_length(window[0], quantum);
        if cl as usize <= quantum as usize {
            spectrum[cl as usize] += 1;
        }
    }

    spectrum
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cascade_length_basic() {
        assert_eq!(cascade_length(0, 8), 1); // 0 → 1: one bit
        assert_eq!(cascade_length(1, 8), 2); // 01 → 10: two bits
        assert_eq!(cascade_length(2, 8), 1); // 10 → 11: one bit
        assert_eq!(cascade_length(3, 8), 3); // 011 → 100: three bits
        assert_eq!(cascade_length(7, 8), 4); // 0111 → 1000: four bits
        assert_eq!(cascade_length(15, 8), 5);
        assert_eq!(cascade_length(31, 8), 6);
        assert_eq!(cascade_length(63, 8), 7);
        assert_eq!(cascade_length(127, 8), 8);
        assert_eq!(cascade_length(255, 8), 8); // All bits flip (wrap)
    }

    #[test]
    fn test_cascade_length_q16() {
        assert_eq!(cascade_length(0, 16), 1);
        assert_eq!(cascade_length(0xFFFF, 16), 16); // All 16 bits flip
        assert_eq!(cascade_length(0x7FFF, 16), 16); // 15 trailing ones + 1
    }

    #[test]
    fn test_cascade_spectrum_simple() {
        // Path 0 → 1 → 2 → 3
        // Cascade lengths: 1 (0→1), 2 (1→2), 1 (2→3)
        let path = [0u64, 1, 2, 3];
        let spectrum = cascade_spectrum(&path, 8);

        assert_eq!(spectrum[1], 2);
        assert_eq!(spectrum[2], 1);
        for value in spectrum.iter().take(9).skip(3) {
            assert_eq!(*value, 0);
        }
    }

    #[test]
    fn test_cascade_spectrum_full_cycle() {
        // Full cycle 0..=255 in 8-bit ring
        let path: Vec<u64> = (0..=255).collect();
        let spectrum = cascade_spectrum(&path, 8);

        // Expected distribution for 255 transitions:
        // P(k) = (1/2)^k means:
        // k=1: ~128 (half of all transitions)
        // k=2: ~64
        // k=3: ~32
        // ...
        // k=8: 2 (127→128 and 255→0)
        assert_eq!(spectrum[1], 128);
        assert_eq!(spectrum[2], 64);
        assert_eq!(spectrum[3], 32);
        assert_eq!(spectrum[4], 16);
        assert_eq!(spectrum[5], 8);
        assert_eq!(spectrum[6], 4);
        assert_eq!(spectrum[7], 2);
        assert_eq!(spectrum[8], 1); // Only 255→0 in 0..=255 path
    }

    #[test]
    fn test_cascade_spectrum_empty() {
        let spectrum = cascade_spectrum(&[], 8);
        assert!(spectrum.iter().all(|&c| c == 0));
    }

    #[test]
    fn test_cascade_spectrum_trait() {
        let path = [0u64, 1, 2, 3];
        let result = CascadeSpectrum::compute(&path, 8);
        assert_eq!(result[1], 2);
        assert_eq!(result[2], 1);
    }

    #[test]
    fn test_cascade_distribution_matches_theory() {
        // For a full cycle 0..=255, verify P(k) = (1/2)^k distribution
        // The distribution comes from counting values with exactly k-1 trailing 1-bits.
        // k=1: values ending in 0 (even numbers): 128 values
        // k=2: values ending in 01: 64 values (1, 5, 9, ... 253)
        // k=3: values ending in 011: 32 values
        // ...
        // k=8: values ending in 1111111 (127) or 11111111 (255): but 255→0 is special
        let path: Vec<u64> = (0..=255).collect();
        let spectrum = cascade_spectrum(&path, 8);

        // Expected counts for each cascade length
        let expected = [0u32, 128, 64, 32, 16, 8, 4, 2, 1];

        for k in 1..=8 {
            assert_eq!(
                spectrum[k], expected[k],
                "Mismatch at cascade length {}: got {}, expected {}",
                k, spectrum[k], expected[k]
            );
        }
    }
}
