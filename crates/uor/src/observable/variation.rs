//! Total variation observable for computation paths.
//!
//! Total variation measures the cumulative unsigned change in stratum (Hamming weight)
//! along a computation path. It captures "turbulence" in the fiber bundle projection.

use super::{stratum, PathObservable};

/// Total variation observable.
///
/// For a path x₀ → x₁ → ... → xₘ, total variation is:
///
/// ```text
/// TV = Σᵢ |stratum(xᵢ₊₁) - stratum(xᵢ)|
/// ```
///
/// High total variation indicates frequent transitions between strata,
/// corresponding to high carry-cascade activity.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct TotalVariation {
    /// The total variation value.
    pub value: u64,
}

impl PathObservable for TotalVariation {
    type Value = u64;

    fn compute(path: &[u64], quantum: u32) -> Self::Value {
        total_variation(path, quantum)
    }
}

/// Compute total variation of a path in Z/(2^quantum)Z.
///
/// Total variation is the sum of absolute differences in stratum (Hamming weight)
/// between consecutive values in the path.
///
/// # Arguments
///
/// * `path` - Sequence of values representing the computation path
/// * `quantum` - Bit width of the ring
///
/// # Returns
///
/// The total variation (non-negative integer).
///
/// # Example
///
/// ```
/// use uor::observable::total_variation;
///
/// // Path: 0 → 1 → 3 → 7
/// // Strata: 0 → 1 → 2 → 3
/// // Deltas: |1-0| + |2-1| + |3-2| = 3
/// let path = [0u64, 1, 3, 7];
/// assert_eq!(total_variation(&path, 8), 3);
/// ```
pub fn total_variation(path: &[u64], quantum: u32) -> u64 {
    if path.len() < 2 || quantum == 0 {
        return 0;
    }

    path.windows(2)
        .map(|w| {
            let s0 = stratum(w[0], quantum) as i64;
            let s1 = stratum(w[1], quantum) as i64;
            (s1 - s0).unsigned_abs()
        })
        .sum()
}

/// Compute normalized total variation (total variation divided by path length).
///
/// Normalized total variation allows comparison across paths of different lengths.
/// For random successor walks, the expected NTV is approximately 1.0.
///
/// # Arguments
///
/// * `path` - Sequence of values representing the computation path
/// * `quantum` - Bit width of the ring
///
/// # Returns
///
/// The normalized total variation (floating point).
///
/// # Example
///
/// ```
/// use uor::observable::normalized_total_variation;
///
/// let path = [0u64, 1, 3, 7]; // TV = 3, length = 4, NTV = 3/3 = 1.0
/// let ntv = normalized_total_variation(&path, 8);
/// assert!((ntv - 1.0).abs() < 0.001);
/// ```
pub fn normalized_total_variation(path: &[u64], quantum: u32) -> f64 {
    if path.len() < 2 {
        return 0.0;
    }

    let tv = total_variation(path, quantum);
    let transitions = (path.len() - 1) as f64;
    tv as f64 / transitions
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_total_variation_simple() {
        // Path with known stratum changes
        // 0 (stratum 0) → 1 (stratum 1) → 3 (stratum 2) → 7 (stratum 3)
        let path = [0u64, 1, 3, 7];
        assert_eq!(total_variation(&path, 8), 3);
    }

    #[test]
    fn test_total_variation_constant_stratum() {
        // All values have same Hamming weight (stratum 1)
        let path = [1u64, 2, 4, 8, 16, 32, 64, 128];
        assert_eq!(total_variation(&path, 8), 0);
    }

    #[test]
    fn test_total_variation_oscillating() {
        // Alternating between stratum 0 and stratum 1
        let path = [0u64, 1, 0, 1, 0, 1];
        // Deltas: 1 + 1 + 1 + 1 + 1 = 5
        assert_eq!(total_variation(&path, 8), 5);
    }

    #[test]
    fn test_total_variation_empty_and_single() {
        assert_eq!(total_variation(&[], 8), 0);
        assert_eq!(total_variation(&[42], 8), 0);
    }

    #[test]
    fn test_total_variation_max_jump() {
        // Jump from stratum 0 to stratum 8 (in 8-bit)
        let path = [0u64, 255]; // 0 bits → 8 bits
        assert_eq!(total_variation(&path, 8), 8);
    }

    #[test]
    fn test_normalized_total_variation() {
        let path = [0u64, 1, 3, 7]; // TV = 3, 3 transitions
        let ntv = normalized_total_variation(&path, 8);
        assert!((ntv - 1.0).abs() < 0.001);
    }

    #[test]
    fn test_normalized_total_variation_zero() {
        // All same stratum
        let path = [1u64, 2, 4, 8];
        let ntv = normalized_total_variation(&path, 8);
        assert_eq!(ntv, 0.0);
    }

    #[test]
    fn test_total_variation_succ_path() {
        // Path generated by successor: 0 → 1 → 2 → 3 → ...
        // Stratum changes on carry cascades
        let path: Vec<u64> = (0..=255).collect();
        let tv = total_variation(&path, 8);

        // TV should be positive (many stratum transitions occur)
        assert!(tv > 0, "TV should be positive, got {}", tv);

        // For 0..=255, the expected total variation is the sum of |stratum(i+1) - stratum(i)|
        // This equals the sum over all transitions of the absolute stratum change
        // Mean should be approximately 1.0 per step
        let ntv = normalized_total_variation(&path, 8);
        assert!(ntv > 0.9 && ntv < 1.1, "NTV should be ~1.0, got {}", ntv);
    }

    #[test]
    fn test_total_variation_trait() {
        let path = [0u64, 1, 3, 7];
        let result = TotalVariation::compute(&path, 8);
        assert_eq!(result, 3);
    }
}
