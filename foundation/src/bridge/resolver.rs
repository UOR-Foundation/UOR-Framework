// @generated by uor-crate from uor-ontology — do not edit manually

//! `resolver/` namespace — Type resolution strategies implementing the partition map Π : T_n → Part(R_n). Resolvers transform type declarations into ring partitions..
//!
//! Space: Bridge

use crate::enums::MetricAxis;
use crate::Primitives;

/// A strategy for resolving a type declaration into a partition of the ring. The kernel dispatches to a specific resolver based on the type's structure.
/// Disjoint with: ResolutionState, RefinementSuggestion.
pub trait Resolver<P: Primitives> {
    /// Associated type for `TypeDefinition`.
    type TypeDefinition: crate::user::type_::TypeDefinition<P>;
    /// The type of input this resolver accepts.
    fn input_type(&self) -> &Self::TypeDefinition;
    /// Associated type for `Partition`.
    type Partition: crate::bridge::partition::Partition<P>;
    /// The type of output this resolver produces. For all UOR resolvers, the output is a partition:Partition.
    fn output_type(&self) -> &Self::Partition;
    /// A human-readable description of the resolution strategy this resolver implements.
    fn strategy(&self) -> &P::String;
    /// The computational complexity of this resolver, expressed as a big-O string (e.g., 'O(n)', 'O(2^n)').
    fn complexity(&self) -> &P::String;
    /// Associated type for `ResolutionState`.
    type ResolutionState: ResolutionState<P>;
    /// The current resolution state of this resolver.
    fn resolution_state(&self) -> &Self::ResolutionState;
}

/// Resolves types by factoring the ring under dihedral group action. Identifies orbits under D_{2^n} to determine irreducibility boundaries.
pub trait DihedralFactorizationResolver<P: Primitives>: Resolver<P> {}

/// Resolves types by computing canonical forms via term rewriting. Applies the critical identity and normalization rules to reduce terms to unique canonical representatives.
pub trait CanonicalFormResolver<P: Primitives>: Resolver<P> {}

/// Resolves types by direct evaluation: applies operations to enumerate ring elements and classify them as irreducible, reducible, unit, or exterior.
pub trait EvaluationResolver<P: Primitives>: Resolver<P> {}

/// The current state of an iterative resolution: tracks how many iterations have been performed, whether the resolution is complete, and the current fiber deficit.
/// Disjoint with: Resolver, RefinementSuggestion.
pub trait ResolutionState<P: Primitives> {
    /// Whether this resolution is complete: all fibers are pinned and the partition is fully determined.
    fn is_complete(&self) -> P::Boolean;
    /// The number of refinement iterations performed so far.
    fn iteration_count(&self) -> P::NonNegativeInteger;
    /// Associated type for `FiberBudget`.
    type FiberBudget: crate::bridge::partition::FiberBudget<P>;
    /// The fiber budget showing the remaining unpinned fibers. When all fibers are pinned, the deficit is zero and resolution is complete.
    fn fiber_deficit(&self) -> &Self::FiberBudget;
    /// Associated type for `RefinementSuggestion`.
    type RefinementSuggestion: RefinementSuggestion<P>;
    /// A refinement suggestion for advancing this resolution.
    fn suggestion(&self) -> &[Self::RefinementSuggestion];
    /// The rate at which fibers are being pinned per iteration. A higher rate indicates faster convergence toward a complete resolution.
    fn convergence_rate(&self) -> P::Decimal;
}

/// A suggestion from the resolver for how to refine an incomplete resolution: which metric axis to explore, which class to narrow to, and which fibers to target.
/// Disjoint with: Resolver, ResolutionState.
pub trait RefinementSuggestion<P: Primitives> {
    /// The metric axis this suggestion recommends exploring.
    fn suggested_axis(&self) -> MetricAxis;
    /// The constraint class this suggestion recommends applying.
    fn suggested_class(&self) -> &P::String;
    /// Associated type for `FiberCoordinate`.
    type FiberCoordinate: crate::bridge::partition::FiberCoordinate<P>;
    /// The fiber coordinates this suggestion targets for pinning.
    fn target_fibers(&self) -> &[Self::FiberCoordinate];
}
