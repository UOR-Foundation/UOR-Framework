// @generated by uor-crate from uor-ontology — do not edit manually

//! Shared enumerations derived from the UOR Foundation ontology.

use core::fmt;

/// Kernel/user/bridge classification for each namespace module.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Space {
    /// Immutable kernel-space: compiled into ROM.
    Kernel,
    /// Parameterizable user-space: runtime declarations.
    User,
    /// Bridge: kernel-computed, user-consumed.
    Bridge,
}

impl fmt::Display for Space {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Kernel => f.write_str("kernel"),
            Self::User => f.write_str("user"),
            Self::Bridge => f.write_str("bridge"),
        }
    }
}

/// The 10 primitive operations defined in the UOR Foundation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PrimitiveOp {
    /// Ring reflection: neg(x) = (-x) mod 2^n. One of the two generators of the dihedral group D_{2^n}. neg(neg(x)) = x (involution property).
    Neg,
    /// Hypercube reflection: bnot(x) = (2^n - 1) ⊕ x (bitwise complement). The second generator of D_{2^n}. bnot(bnot(x)) = x.
    Bnot,
    /// Successor: succ(x) = neg(bnot(x)) = (x + 1) mod 2^n. The critical identity: succ is the composition neg ∘ bnot.
    Succ,
    /// Predecessor: pred(x) = bnot(neg(x)) = (x - 1) mod 2^n. The inverse of succ. pred is the composition bnot ∘ neg.
    Pred,
    /// Ring addition: add(x, y) = (x + y) mod 2^n. Commutative, associative; identity element is 0.
    Add,
    /// Ring subtraction: sub(x, y) = (x - y) mod 2^n. Not commutative, not associative.
    Sub,
    /// Ring multiplication: mul(x, y) = (x × y) mod 2^n. Commutative, associative; identity element is 1.
    Mul,
    /// Bitwise exclusive or: xor(x, y) = x ⊕ y. Commutative, associative; identity element is 0.
    Xor,
    /// Bitwise and: and(x, y) = x ∧ y. Commutative, associative.
    And,
    /// Bitwise or: or(x, y) = x ∨ y. Commutative, associative.
    Or,
}

impl fmt::Display for PrimitiveOp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Neg => f.write_str("neg"),
            Self::Bnot => f.write_str("bnot"),
            Self::Succ => f.write_str("succ"),
            Self::Pred => f.write_str("pred"),
            Self::Add => f.write_str("add"),
            Self::Sub => f.write_str("sub"),
            Self::Mul => f.write_str("mul"),
            Self::Xor => f.write_str("xor"),
            Self::And => f.write_str("and"),
            Self::Or => f.write_str("or"),
        }
    }
}

/// The three metric axes in the UOR tri-metric classification.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum MetricAxis {
    /// The vertical (ring/additive) metric axis. Constraints on this axis operate through ring arithmetic: residue classes, divisibility, and additive structure.
    Vertical,
    /// The horizontal (Hamming/bitwise) metric axis. Constraints on this axis operate through bitwise structure: carry patterns, bit positions, and Hamming distance.
    Horizontal,
    /// The diagonal (incompatibility) metric axis. Constraints on this axis measure the gap between ring and Hamming metrics — the curvature of UOR geometry.
    Diagonal,
}

impl fmt::Display for MetricAxis {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Vertical => f.write_str("vertical"),
            Self::Horizontal => f.write_str("horizontal"),
            Self::Diagonal => f.write_str("diagonal"),
        }
    }
}

/// The state of a fiber coordinate: pinned or free.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FiberState {
    /// Fiber is determined by a constraint.
    Pinned,
    /// Fiber is still available for refinement.
    Free,
}

impl fmt::Display for FiberState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Pinned => f.write_str("pinned"),
            Self::Free => f.write_str("free"),
        }
    }
}

/// The geometric character of an operation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum GeometricCharacter {
    /// ring_reflection geometric character.
    RingReflection,
    /// hypercube_reflection geometric character.
    HypercubeReflection,
    /// rotation geometric character.
    Rotation,
    /// rotation_inverse geometric character.
    RotationInverse,
    /// translation geometric character.
    Translation,
    /// scaling geometric character.
    Scaling,
    /// hypercube_translation geometric character.
    HypercubeTranslation,
    /// hypercube_projection geometric character.
    HypercubeProjection,
    /// hypercube_join geometric character.
    HypercubeJoin,
}

impl fmt::Display for GeometricCharacter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::RingReflection => f.write_str("ring_reflection"),
            Self::HypercubeReflection => f.write_str("hypercube_reflection"),
            Self::Rotation => f.write_str("rotation"),
            Self::RotationInverse => f.write_str("rotation_inverse"),
            Self::Translation => f.write_str("translation"),
            Self::Scaling => f.write_str("scaling"),
            Self::HypercubeTranslation => f.write_str("hypercube_translation"),
            Self::HypercubeProjection => f.write_str("hypercube_projection"),
            Self::HypercubeJoin => f.write_str("hypercube_join"),
        }
    }
}
