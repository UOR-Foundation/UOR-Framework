// @generated by uor-crate from uor-ontology — do not edit manually

//! `type/` namespace — Runtime type declarations that parameterize the resolution pipeline. Types are declared by Prism applications and resolved to partitions of the ring..
//!
//! Space: User

use crate::enums::MetricAxis;
use crate::Primitives;

/// A runtime type declaration. The root class for all UOR types. Each TypeDefinition, when resolved, produces a partition of the ring at the specified quantum level.
/// Disjoint with: Constraint, MetricAxis.
pub trait TypeDefinition<P: Primitives> {
    /// Associated type for `Address`.
    type Address: crate::kernel::address::Address<P>;
    /// The content-derived address of this type definition, uniquely identifying the type in the UOR address space.
    fn content_address(&self) -> &Self::Address;
}

/// A primitive type defined by a fixed bit width. The carrier is the entire ring Z/(2^n)Z at the specified quantum level.
pub trait PrimitiveType<P: Primitives>: TypeDefinition<P> {
    /// The bit width of a primitive type (the quantum level n). The carrier is Z/(2^n)Z.
    fn bit_width(&self) -> P::PositiveInteger;
}

/// A product (Cartesian) type formed from multiple component types. The carrier is the product of the component carriers.
pub trait ProductType<P: Primitives>: TypeDefinition<P> {
    /// Associated type for `TypeDefinition`.
    type TypeDefinition: TypeDefinition<P>;
    /// A component type in a product type.
    fn component(&self) -> &[Self::TypeDefinition];
}

/// A sum (disjoint union) type formed from multiple variant types. The carrier is the disjoint union of the variant carriers.
pub trait SumType<P: Primitives>: TypeDefinition<P> {}

/// A type formed by constraining a base type with a predicate. The carrier is the subset of the base carrier satisfying the constraint.
pub trait ConstrainedType<P: Primitives>: TypeDefinition<P> {
    /// Associated type for `TypeDefinition`.
    type TypeDefinition: TypeDefinition<P>;
    /// The base type that a constrained type restricts.
    fn base_type(&self) -> &Self::TypeDefinition;
    /// The constraint predicate applied to the base type. Expressed as a string in the Prism constraint language. Deprecated in favor of type:hasConstraint (Amendment 10), which provides typed object references to Constraint individuals. Retained for backwards compatibility.
    fn constraint_count(&self) -> usize;
    /// Associated type for `Constraint`.
    type Constraint: Constraint<P>;
    /// A typed constraint object applied to this constrained type. Replaces the deprecated string-based type:constraint property.
    fn has_constraint(&self) -> &[Self::Constraint];
}

/// A composable predicate that refines a type by pinning one or more fiber coordinates. Constraints are the parameterization mechanism for ConstrainedType.
/// Disjoint with: TypeDefinition, MetricAxis.
pub trait Constraint<P: Primitives> {
    /// The metric axis along which this constraint operates: vertical (ring), horizontal (Hamming), or diagonal (incompatibility).
    fn metric_axis(&self) -> MetricAxis;
    /// Associated type for `FiberCoordinate`.
    type FiberCoordinate: crate::bridge::partition::FiberCoordinate<P>;
    /// A fiber coordinate that this constraint pins when applied.
    fn pins_fibers(&self) -> &[Self::FiberCoordinate];
    /// The cost of applying this constraint in terms of axis crossings: the number of metric boundaries that must be traversed.
    fn crossing_cost(&self) -> P::NonNegativeInteger;
}

/// A constraint based on residue class membership: x ≡ r (mod m). Pins fibers corresponding to the residue pattern.
/// Disjoint with: CarryConstraint, DepthConstraint, CompositeConstraint.
pub trait ResidueConstraint<P: Primitives>: Constraint<P> {
    /// The modulus m of a residue constraint: x ≡ r (mod m).
    fn modulus(&self) -> P::PositiveInteger;
    /// The residue value r of a residue constraint: x ≡ r (mod m).
    fn residue(&self) -> P::NonNegativeInteger;
}

/// A constraint based on carry propagation patterns in ring arithmetic. Pins fibers corresponding to carry positions.
/// Disjoint with: ResidueConstraint, DepthConstraint, CompositeConstraint.
pub trait CarryConstraint<P: Primitives>: Constraint<P> {
    /// The carry propagation pattern of a carry constraint, expressed as a binary string (e.g., '1010').
    fn carry_pattern(&self) -> &P::String;
}

/// A constraint on factorization depth: the minimum and maximum number of irreducible factors. Pins fibers by bounding the factorization tree depth.
/// Disjoint with: ResidueConstraint, CarryConstraint, CompositeConstraint.
pub trait DepthConstraint<P: Primitives>: Constraint<P> {
    /// The minimum factorization depth required by a depth constraint.
    fn min_depth(&self) -> P::NonNegativeInteger;
    /// The maximum factorization depth allowed by a depth constraint.
    fn max_depth(&self) -> P::NonNegativeInteger;
}

/// A constraint formed by composing two or more simpler constraints. The composite pins the union of fibers pinned by its components.
/// Disjoint with: ResidueConstraint, CarryConstraint, DepthConstraint.
pub trait CompositeConstraint<P: Primitives>: Constraint<P> {
    /// Associated type for `Constraint`.
    type Constraint: Constraint<P>;
    /// A component constraint of this composite constraint.
    fn composed_from(&self) -> &[Self::Constraint];
}
