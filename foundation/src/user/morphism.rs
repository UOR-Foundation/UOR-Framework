// @generated by uor-crate from uor-ontology ‚Äî do not edit manually

//! `morphism/` namespace ‚Äî Runtime abstractions for maps between UOR objects: transforms, isometries, embeddings, and group actions. The foundation provides the vocabulary; Prism writes the sentences..
//!
//! Space: User

use crate::Primitives;

/// A map between UOR objects. The root abstraction: source, target, and optionally what structure (if any) is preserved. This is what cert:TransformCertificate certifies.
/// Disjoint with: CompositionLaw.
pub trait Transform<P: Primitives> {
    /// The domain of the transform.
    fn source(&self) -> &P::String;
    /// The codomain of the transform.
    fn target(&self) -> &P::String;
    /// The structure preserved by this transform (if any). E.g., a ring homomorphism preserves addition and multiplication.
    fn preserves_count(&self) -> usize;
    /// Associated type for `ComputationTrace`.
    type ComputationTrace: crate::bridge::trace::ComputationTrace<P>;
    /// The computation trace that realized this transform at runtime. A Transform is an abstraction; a trace is the kernel's record of how it was executed via concrete operations.
    fn trace(&self) -> &Self::ComputationTrace;
    /// Associated type for `Transform`.
    type TransformTarget: Transform<P>;
    /// A transform that this transform can be composed with. The target of this transform must match the source of the composed transform.
    fn composes_with(&self) -> &[Self::TransformTarget];
    /// A human-readable description of the structure this transform preserves (e.g., 'ring homomorphism', 'metric isometry').
    fn preserves_structure(&self) -> &P::String;
}

/// A transform that preserves metric structure with respect to a specified metric. In UOR, isometry is metric-relative: neg is a ring isometry, bnot is a Hamming isometry. A transform can be an isometry with respect to one metric but not the other. This is what cert:IsometryCertificate certifies.
/// Disjoint with: Composition.
pub trait Isometry<P: Primitives>: Transform<P> {
    /// Associated type for `MetricObservable`.
    type MetricObservable: crate::bridge::observable::MetricObservable<P>;
    /// The specific metric this isometry preserves. Points to observable:RingMetric or observable:HammingMetric. A transform that preserves both is an isometry of the full UOR geometry. A transform that preserves one but not the other has nontrivial curvature ‚Äî observable:CurvatureObservable measures this gap.
    fn preserves_metric(&self) -> &[Self::MetricObservable];
}

/// An injective, structure-preserving transform across quantum levels. The canonical instance is the level embedding Œπ : R_n ‚Üí R_{n'} (n < n'), which preserves addition, multiplication, and content addressing.
/// Disjoint with: Composition.
pub trait Embedding<P: Primitives>: Transform<P> {
    /// The quantum level n of the source ring for an embedding.
    fn source_quantum(&self) -> P::PositiveInteger;
    /// The quantum level n' of the target ring for an embedding. Must satisfy n' > n (embeddings go to larger rings).
    fn target_quantum(&self) -> P::PositiveInteger;
}

/// The mechanism by which a group applies transforms systematically to a set. Each group element induces a transform of the set. The dihedral action on type space is an action by isometries ‚Äî every element of D_{2^n} produces an isometric transform of ùíØ_n.
pub trait Action<P: Primitives> {
    /// Associated type for `Group`.
    type Group: crate::kernel::op::Group<P>;
    /// The group acting in this group action.
    fn group(&self) -> &Self::Group;
    /// The set being acted upon by this group action.
    fn acting_on(&self) -> &P::String;
    /// Whether every transform induced by this action is an isometry. True for the dihedral action on ùíØ_n (Frame Theorem).
    fn action_isometry(&self) -> P::Boolean;
}

/// A transform formed by composing two or more transforms sequentially. The categorical composition operation that turns transforms into a category.
/// Disjoint with: Isometry, Embedding, Identity.
pub trait Composition<P: Primitives>: Transform<P> {
    /// Associated type for `Transform`.
    type Transform: Transform<P>;
    /// The transform that results from this composition.
    fn composition_result(&self) -> &Self::Transform;
    /// A component transform of this composition.
    fn composition_components(&self) -> &[Self::Transform];
}

/// The identity transform on a type: maps every element to itself. The categorical identity morphism.
/// Disjoint with: Composition.
pub trait Identity<P: Primitives>: Transform<P> {
    /// Associated type for `TypeDefinition`.
    type TypeDefinition: crate::user::type_::TypeDefinition<P>;
    /// The type on which this identity transform acts.
    fn identity_on(&self) -> &Self::TypeDefinition;
}

/// A law governing how operations compose. Records whether the composition is associative, commutative, and what the result operation is. The critical composition law (neg ‚àò bnot = succ) is the foundational instance.
/// Disjoint with: Transform.
pub trait CompositionLaw<P: Primitives> {
    /// Whether this composition law is associative.
    fn is_associative(&self) -> P::Boolean;
    /// Whether this composition law is commutative.
    fn is_commutative(&self) -> P::Boolean;
    /// Associated type for `Operation`.
    type Operation: crate::kernel::op::Operation<P>;
    /// An operation that is a component of this composition law.
    fn law_components(&self) -> &[Self::Operation];
    /// The operation that results from this composition law.
    fn law_result(&self) -> &Self::Operation;
}

/// The critical composition law: neg ‚àò bnot = succ. This is the operational form of the critical identity theorem. The composition of the two involutions (neg, bnot) yields the successor operation. Non-associative and non-commutative.
pub mod critical_composition {
    /// `isAssociative`
    pub const IS_ASSOCIATIVE: bool = false;
    /// `isCommutative`
    pub const IS_COMMUTATIVE: bool = false;
    /// `lawComponents`
    pub const LAW_COMPONENTS: &[&str] = &[
        "https://uor.foundation/op/neg",
        "https://uor.foundation/op/bnot",
    ];
    /// `lawResult` -> `succ`
    pub const LAW_RESULT: &str = "https://uor.foundation/op/succ";
}
